{
    "collab_server" : "",
    "contents" : "n.input <- 1600\nn.hidden <- 26\nn.output <- 50\nlearning.rate <- 0.1\nn.epochs <- 1000\nn.test <- 26\ntrace.hidden <- rep(0, times = n.hidden)\ntrace.output <- rep(0, times = n.output)\ntrace.param.hidden <- 1 # value of 1 indicates pure hebbian learning. Closer to zero, more of 'history' of node activation is taken into account\ntrace.param.output <- 0.2\n\n\n#install.packages('png')\nlibrary('png')\n#install.packages('abind')\nlibrary('abind')\n\nalphabet <- list(\n  a <- as.vector(t(1-adrop(readPNG('AlphabetPNG/A.png')[,,1,drop=F], drop=3))),\n  b <- as.vector(t(1-adrop(readPNG('AlphabetPNG/B.png')[,,1,drop=F], drop=3))),\n  c <- as.vector(t(1-adrop(readPNG('AlphabetPNG/C.png')[,,1,drop=F], drop=3))),\n  d <- as.vector(t(1-adrop(readPNG('AlphabetPNG/D.png')[,,1,drop=F], drop=3))),\n  e <- as.vector(t(1-adrop(readPNG('AlphabetPNG/E.png')[,,1,drop=F], drop=3))),\n  f <- as.vector(t(1-adrop(readPNG('AlphabetPNG/F.png')[,,1,drop=F], drop=3))),\n  g <- as.vector(t(1-adrop(readPNG('AlphabetPNG/G.png')[,,1,drop=F], drop=3))),\n  h <- as.vector(t(1-adrop(readPNG('AlphabetPNG/H.png')[,,1,drop=F], drop=3))),\n  i <- as.vector(t(1-adrop(readPNG('AlphabetPNG/I.png')[,,1,drop=F], drop=3))),\n  j <- as.vector(t(1-adrop(readPNG('AlphabetPNG/J.png')[,,1,drop=F], drop=3))),\n  k <- as.vector(t(1-adrop(readPNG('AlphabetPNG/K.png')[,,1,drop=F], drop=3))),\n  l <- as.vector(t(1-adrop(readPNG('AlphabetPNG/L.png')[,,1,drop=F], drop=3))),\n  m <- as.vector(t(1-adrop(readPNG('AlphabetPNG/M.png')[,,1,drop=F], drop=3))),\n  n <- as.vector(t(1-adrop(readPNG('AlphabetPNG/N.png')[,,1,drop=F], drop=3))),\n  o <- as.vector(t(1-adrop(readPNG('AlphabetPNG/O.png')[,,1,drop=F], drop=3))),\n  p <- as.vector(t(1-adrop(readPNG('AlphabetPNG/P.png')[,,1,drop=F], drop=3))),\n  q <- as.vector(t(1-adrop(readPNG('AlphabetPNG/Q.png')[,,1,drop=F], drop=3))),\n  r <- as.vector(t(1-adrop(readPNG('AlphabetPNG/R.png')[,,1,drop=F], drop=3))),\n  s <- as.vector(t(1-adrop(readPNG('AlphabetPNG/S.png')[,,1,drop=F], drop=3))),\n  t <- as.vector(t(1-adrop(readPNG('AlphabetPNG/T.png')[,,1,drop=F], drop=3))),\n  u <- as.vector(t(1-adrop(readPNG('AlphabetPNG/U.png')[,,1,drop=F], drop=3))),\n  v <- as.vector(t(1-adrop(readPNG('AlphabetPNG/V.png')[,,1,drop=F], drop=3))),\n  w <- as.vector(t(1-adrop(readPNG('AlphabetPNG/W.png')[,,1,drop=F], drop=3))),\n  x <- as.vector(t(1-adrop(readPNG('AlphabetPNG/X.png')[,,1,drop=F], drop=3))),\n  y <- as.vector(t(1-adrop(readPNG('AlphabetPNG/Y.png')[,,1,drop=F], drop=3))),\n  z <- as.vector(t(1-adrop(readPNG('AlphabetPNG/Z.png')[,,1,drop=F], drop=3)))\n)\n\nwords <- list(\n  cat <- cbind(c,a,t), bow <- cbind(b,o,w),\n  sip <- cbind(s,i,p), rad <- cbind(r,a,d),\n  zen <- cbind(z,e,n), two <- cbind(t,w,o),\n  rub <- cbind(r,u,b), vex <- cbind(v,e,x),\n  fox <- cbind(f,o,x), wry <- cbind(w,r,y),\n  vow <- cbind(v,o,w), zag <- cbind(z,a,g),\n  quo <- cbind(q,u,o), fry <- cbind(f,r,y),\n  the <- cbind(t,h,e), pew <- cbind(p,e,w),\n  dug <- cbind(d,u,g), keg <- cbind(k,e,w),\n  yak <- cbind(y,a,k), tax <- cbind(t,a,x),\n  jaw <- cbind(j,a,w), who <- cbind(w,h,o),\n  lax <- cbind(l,a,x), til <- cbind(t,i,l),\n  sin <- cbind(s,i,n), mud <- cbind(m,u,d),\n  yap <- cbind(y,a,p), orb <- cbind(o,r,b),\n  ply <- cbind(p,l,y), cry <- cbind(c,r,y),\n  tom <- cbind(t,o,m), coy <- cbind(c,o,y),\n  any <- cbind(a,n,y), jot <- cbind(j,o,t),\n  she <- cbind(s,h,e), gig <- cbind(g,i,g),\n  axe <- cbind(a,x,e), icy <- cbind(i,c,y),\n  elm <- cbind(e,l,m), owl <- cbind(o,w,l),\n  gag <- cbind(g,a,g), nun <- cbind(n,u,n),\n  jay <- cbind(j,a,y), rye <- cbind(r,y,e),\n  apt <- cbind(a,p,t), sty <- cbind(s,t,y),\n  lit <- cbind(l,i,t), why <- cbind(w,h,y),\n  hue <- cbind(h,u,e), use <- cbind(u,s,e)\n)\n\n\n\ninput.hidden.weights <- matrix(runif(n.input*n.hidden, min=0, max=1), nrow=n.input, ncol=n.hidden) #initialiize weights at random values between 1 and 0\nhidden.output.weights <- matrix(runif(n.hidden*n.output, min=0, max=1), nrow=n.hidden, ncol=n.output)\n\n\nsigmoid.activation <- function(x){\n  return(1 / (1+exp(-x)))\n}\n\n\nforward.pass <- function(input){ #calculate output activations with \"winner-takes-all\" method\n  \n  hidden <- numeric(n.hidden)\n  for(i in 1:n.hidden){\n    hidden[i] <- sigmoid.activation(sum(input * input.hidden.weights[,i]))\n  }\n  hidden[which.max(hidden)] <- 1\n  hidden[hidden != max(hidden)] <- 0\n  return(hidden)\n  #output <- numeric(n.output)\n  #for(b in 1:n.output){\n  #  output[b] <- sigmoid.activation(sum(hidden * hidden.output.weights[,b]))\n  #}\n  #output[which.max(output)] <- 1\n  #output[output != max(output)] <- 0\n  #return(list(hidden=hidden, output=output))\n}\n\ntrace.update <- function(input, input.hidden.weights, trace.hidden){\n  #trace.update <- function(input, input.hidden.weights, hidden.output.weights, trace.hidden, trace.output){ \n  \n  hidden <- forward.pass(input)\n  #forward.pass.results <- forward.pass(input)\n  #hidden <- forward.pass.results$hidden\n  #output <- forward.pass.results$output\n  \n  for(i in 1:n.hidden){\n    trace.hidden[i] <- (1 - trace.param.hidden) * trace.hidden[i]  + trace.param.hidden * hidden[i] \n    input.hidden.weights[,i] <- input.hidden.weights[,i] + learning.rate * trace.hidden[i] * (input - input.hidden.weights[,i])  \n  }\n  return(list(trace.hidden=trace.hidden, input.hidden.weights=input.hidden.weights))\n  \n  #for(b in 1:n.output){\n  #  trace.output <- (1 - trace.param.output) * trace.output[b] + trace.param.output * output[b]\n  #  hidden.output.weights[,b] <- hidden.output.weights[,b] + learning.rate * trace.output[i] * (hidden - hidden.output.weights[,b])\n  #}\n  #return(list(trace.hidden=trace.hidden, trace.ouput=trace.output, input.hidden.weights=input.hidden.weights, hidden.output.weights=hidden.output.weights))\n}\n\n\nbatch <- function(n.epochs){ \n  \n  for(i in 1:n.epochs){\n    letter <- alphabet[[sample(1:26,1, replace = T)]]\n    #results <- trace.update(letter, input.hidden.weights, hidden.output.weights, trace.hidden, trace.output)\n    results <- trace.update(letter, input.hidden.weights, trace.hidden)\n    input.hidden.weights <- results$input.hidden.weights\n    #hidden.output.weights <- results$hidden.output.weights\n  }\n  return(output.storage())\n}\nword <- words[[sample(1:50,1, replace=T)]]\n#batch <- function(n.epochs){ \n  \n  #for(i in 1:n.epochs){\n    #word <- words[[sample(1:50,1, replace = T)]]\n    #for(b in 1:(length(word)/n.input)){\n      #letter[b] <- word[b]\n      #results <- trace.update(letter[b], input.hidden.weights, hidden.output.weights, trace.hidden, trace.output)\n      #results <- trace.update(letter[b], input.hidden.weights, trace.hidden)\n      #input.hidden.weights <- results$input.hidden.weights\n      #hidden.output.weights <- results$hidden.output.weights\n    #}\n  #}\n  #return(output.storage())\n#}\n\nbatch(n.epochs)  #run training batches\ntest <- output.storage()\n\n\n\n\n## entropy testing functions ##\n\noutput.storage <- function(){ #stores outputs \n  hidden.outputs <- matrix(0, nrow = n.test, ncol = n.hidden)\n  for(i in 1:26){\n    one.hidden <- forward.pass(alphabet[[i]])\n    hidden.outputs[i,] <- one.hidden\n  }\n  return(hidden.outputs)\n}\n\n\nentropy.calc <- function(v){ #function to pass in matrix and get entropy\n  v <- v / sum(v)\n  e.sum <- 0\n  for(i in 1:length(v)){\n    if(v[i] != 0){\n      e.sum <- e.sum + -v[i] * log2(v[i])\n    }\n  }\n  return(e.sum)\n}\n\n\n\ncolsums.function <- function(){ #calculate average entropy of output activations\n  outputs <- output.storage()\n  stability.one <- colSums(outputs)\n  return(stability.one)\n}\n\n\nentropy.measure <- function(){ #calculate average entropy of output activations for each group\n  outputs <- output.storage()\n  entropy <- numeric(10)\n  for(i in 1:10){\n    stability.one <- colSums(outputs[((i-1) * 100 + 1):(i * 100),])\n    entropy[i] <- entropy.calc(stability.one)\n  }\n  return(mean(entropy))\n}\n\n\n\n",
    "created" : 1488227377117.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2671427606",
    "id" : "A3CF809C",
    "lastKnownWriteTime" : 1488227952,
    "last_content_update" : 1488227952449,
    "path" : "~/GitHub/Int-Seg-Model/Spatial Pooling.R",
    "project_path" : "Spatial Pooling.R",
    "properties" : {
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}