{
    "collab_server" : "",
    "contents" : "display.learning.curves <- function(results){\n  for(i in 1:n.hidden){\n    layout(matrix(1:4, nrow=2))\n    #plot(results$history$learning.curve[,i], main=paste(\"Node\",i), ylim = 0,1000)\n    plot(results$history$bias.tracker[,i])\n    image(t(apply(matrix(results$network$input.hidden.weights[,i], nrow = 40),1,rev)))\n  }\n}\n\ndisplay.output.bias.tracker <- function(results){\n  for(i in 1:n.output){\n    plot(results$history$output.bias.tracker[,i], main=paste('Node', i))\n  }\n}\n\ntest.word.continuity <- function(network, words){\n  \n  n.letters <- 0\n  for(i in 1:length(words)){\n    n.letters <- n.letters + ncol(words[[i]])\n  }\n  \n  input.matrix <- matrix(0, ncol=n.input, nrow=n.letters)\n  r <- 1\n  for(i in 1:length(words)){\n    for(j in 1:ncol(words[[i]])){\n      input.matrix[r,] <- words[[i]][,j]\n      r <- r + 1\n    }\n  }\n  \n  temp.layer.activations(network, input.matrix)\n} \n\n\ntemp.layer.activations <- function(network, input.matrix){\n  \n  storing.activations <- matrix(0, nrow=nrow(input.matrix), ncol=n.output)\n  \n  for(i in 1:nrow(input.matrix)){\n    act.results <- forward.pass(input.matrix[i,], network$input.hidden.weights, network$hidden.bias.weights, network$hidden.output.weights, network$output.bias.weights)\n    storing.activations[i,] <- act.results$output\n  }\n  \n  output.results <- data.frame(letter=numeric(),output=numeric())\n  for(i in 1:nrow(storing.activations)){\n    for(j in which(storing.activations[i,] == max(storing.activations[i,]))){\n      output.results <- rbind(output.results, c(letter=i, output=j))  \n    }\n  }\n  colnames(output.results) <- c(\"letter\", \"output\")\n  \n  ## accuracy measurement ##\n  n <- 1\n  g <- (n.output/10) * 3\n  g. <- (n.output/10) * 3\n  \n  counter <- 0\n  for(h in 1:n.output){\n    counter <- counter + sum(c(output.results$output[n:g]) == h)\n  }\n  counter <- counter - length(unique(c(output.results$output[n:g])))\n  n <- g + 1\n  g <- g + g.\n  \n  for(h in 1:n.output){\n    counter <- counter + sum(c(output.results$output[n:g]) == h)\n  }\n  counter <- counter - length(unique(c(output.results$output[n:g])))\n  n <- g + 1\n  g <- g + g.\n  \n  for(h in 1:n.output){\n    counter <- counter + sum(c(output.results$output[n:g]) == h)\n  }\n  counter <- counter - length(unique(c(output.results$output[n:g])))\n  n <- g + 1\n  g <- g + g.\n  \n  for(h in 1:n.output){\n    counter <- counter + sum(c(output.results$output[n:g]) == h)\n  }\n  counter <- counter - length(unique(c(output.results$output[n:g])))\n  n <- g + 1\n  g <- g + g.\n  \n  for(h in 1:n.output){\n    counter <- counter + sum(c(output.results$output[n:g]) == h)\n  }\n  counter <- counter - length(unique(c(output.results$output[n:g])))\n  n <- g + 1\n  g <- g + g.\n  \n  for(h in 1:n.output){\n    counter <- counter + sum(c(output.results$output[n:g]) == h)\n  }\n  counter <- counter - length(unique(c(output.results$output[n:g])))\n  n <- g + 1\n  g <- g + g.\n  \n  for(h in 1:n.output){\n    counter <- counter + sum(c(output.results$output[n:g]) == h)\n  }\n  counter <- counter - length(unique(c(output.results$output[n:g])))\n  n <- g + 1\n  g <- g + g.\n  \n  for(h in 1:n.output){\n    counter <- counter + sum(c(output.results$output[n:g]) == h)\n  }\n  counter <- counter - length(unique(c(output.results$output[n:g])))\n  n <- g + 1\n  g <- g + g.\n  \n  for(h in 1:n.output){\n    counter <- counter + sum(c(output.results$output[n:(g-(n.output/10))]) == h)\n  }\n  counter <- counter - length(unique(c(output.results$output[n:(g-(n.output/10))])))\n  \n  percentage <- counter/(((n.output/10)*2*26) - (n.output/10))\n  ###\n  \n  g <- ggplot(output.results, aes(x=letter, y=output)) + \n    geom_point()+\n    ylim(1,50)+\n    theme_bw()\n  print(g)\n  \n  print(storing.activations)\n  sprintf(\"Percent paired: %f\", percentage)\n}\n\nvisualize.letter.activations <- function(network, input){\n  result <- forward.pass(input, network$input.hidden.weights, network$hidden.bias.weights, network$hidden.output.weights, network$output.bias.weights)\n  active.nodes <- which(result$hidden == max(result$hidden))\n  nplots <- length(active.nodes) + 2\n  nrow <- round(sqrt(nplots))\n  ncol <- ceiling(nplots / nrow)\n  layout(matrix(1:(nrow*ncol), nrow=nrow))\n  image(t(apply(matrix(input, nrow = 40),1,rev)))\n  for(act in active.nodes){\n    image(t(apply(matrix(network$input.hidden.weights[,act], nrow = 40),1,rev)))\n  }\n  all.active.nodes <- network$input.hidden.weights[,active.nodes]\n  m.fun <- function(x) { return(mean(x, na.rm=T)) }\n  average.weights <- apply(all.active.nodes, 1, m.fun)\n  image(t(apply(matrix(average.weights, nrow = 40),1,rev)))\n}\n",
    "created" : 1492957227710.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "437989657",
    "id" : "306964D7",
    "lastKnownWriteTime" : 1492961071,
    "last_content_update" : 1492961071050,
    "path" : "~/GitHub/Int-Seg-Model/Visualize Output.R",
    "project_path" : "Visualize Output.R",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "relative_order" : 2,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}