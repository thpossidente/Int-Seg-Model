{
    "collab_server" : "",
    "contents" : "#include <Rcpp.h>\nusing namespace Rcpp;\n\n// This is a simple example of exporting a C++ function to R. You can\n// source this function into an R session using the Rcpp::sourceCpp \n// function (or via the Source button on the editor toolbar). Learn\n// more about Rcpp at:\n//\n//   http://www.rcpp.org/\n//   http://adv-r.had.co.nz/Rcpp.html\n//   http://gallery.rcpp.org/\n//\n\n// [[Rcpp::export]]\n\n\nList forwardPass(NumericVector input, NumericMatrix inputToHiddenWeights, NumericMatrix hiddenBiasWeights, NumericMatrix hiddenToOutputWeights, NumericMatrix outputBiasWeights){\n  \n  Environment env = Environment::global_env();\n  \n  NumericVector hidden;\n  int n_hidden = env[\"n.hidden\"];\n  for(int i=0; i<n_hidden; i++){\n    hidden[i] += hiddenBiasWeights(i,0);\n    for(int j=0; j<input.length(); j++){\n      if(inputToHiddenWeights(j,i) != R_NaN) {\n        hidden[i] += input[j] * inputToHiddenWeights(j,i);\n      }\n    }\n  }\n  \n  int largest;\n  int percentActInput = env[\"percent.act.input\"];\n  int number = ceil(percentActInput * n_hidden);\n  for(int c=0; c<number; c++){\n    largest = which_max(hidden);\n    hidden[largest] = -1;\n  }\n  \n  for(int x=0; x<n_hidden; x++){\n    if(hidden[x] == -1){\n      hidden[x] = 1;\n    } else{\n      hidden[x] = 0;\n    }\n  }\n  \n  NumericVector output;\n  int n_output = env[\"n.output\"];\n  for(int z=0; z<n_output; z++){\n    output[z] += outputBiasWeights(z,0);\n    for(int h=0; h<n_hidden; h++){\n      if(hiddenToOutputWeights(h,z) != R_NaN) {\n        output[h] += hidden[h] * hiddenToOutputWeights(h,z);\n      }\n    }\n  }\n  \n  int largest1;\n  int percentActOutput = env[\"percent.act.output\"];\n  int number1 = ceil(percentActOutput * n_output);\n  for(int k=0; k<number1; k++){\n    largest1 = which_max(output);\n    output[largest1] = -1;\n  }\n  \n  for(int d=0; d<n_output; d++){\n    if(output[d] == -1){\n      output[d] = 1;\n    } else{\n      output[d] = 0;\n    }\n  }\n  \n  List retrn = List::create(Named(\"hidden\") = hidden,_[\"output\"] = output); \n  return(retrn);\n}\n\n// [[Rcpp::export]]\n\nList traceUpdate(NumericVector input, NumericMatrix inputToHiddenWeights, NumericVector traceHidden, NumericMatrix hiddenBiasWeights, NumericMatrix hiddenToOutputWeights, NumericVector traceOutput, NumericMatrix outputBiasWeights){\n  \n  Environment env = Environment::global_env();\n  \n  List forwardPassResults = forwardPass(input, inputToHiddenWeights, hiddenBiasWeights, hiddenToOutputWeights, outputBiasWeights);\n  \n  NumericVector hidden = forwardPassResults[0];\n  NumericVector output = forwardPassResults[1];\n  \n  int n_hidden = env[\"n.hidden\"];\n  int hiddenBiasParamMinus = env[\"hidden.bias.param.minus\"];\n  int hiddenBiasParamPlus = env[\"hidden.bias.param.plus\"];\n  for(int x=0; x<n_hidden; x++){\n    if(hidden[x] == 1){\n      hiddenBiasWeights(x,0) = hiddenBiasWeights(x,0) - hiddenBiasParamMinus;\n    }\n    if(hidden[x] == 0){\n      hiddenBiasWeights(x,0) = hiddenBiasWeights(x,0) + hiddenBiasParamPlus;\n    }\n    if(hiddenBiasWeights(x,0) < 0){\n      hiddenBiasWeights(x,0) = 0;\n    }\n  }\n  \n  int traceParamHidden = env[\"trace.param.hidden\"];\n  int learningRateHidden = env[\"learning.rate.hidden\"];\n  for(int i=0; i<n_hidden; i++){\n    traceHidden[i] = (1 - traceParamHidden) * traceHidden[i] + traceParamHidden * hidden[i];\n    inputToHiddenWeights(_,i) = inputToHiddenWeights(_,i) + learningRateHidden * traceHidden[i] * (input - inputToHiddenWeights(_,i));\n  }\n  \n  int n_output = env[\"n.output\"];\n  int outputBiasParamMinus = env[\"output.bias.param.minus\"];\n  int outputBiasParamPlus = env[\"output.bias.param.plus\"];\n  for(int b=0; b<n_output; b++){\n    if(output[b] == 1){\n      outputBiasWeights(b,0) = outputBiasWeights(b,0) - outputBiasParamMinus;\n    }\n    if(output[b] == 0){\n      outputBiasWeights(b,0) = outputBiasWeights(b,0) + outputBiasParamPlus;\n    }\n    if(outputBiasWeights(b,0) < 0){\n      outputBiasWeights(b,0) = 0;\n    }\n  }\n  \n  int traceParamOutput = env[\"trace.param.output\"];\n  int learningRateOutput = env[\"learning.rate.output\"];\n  for(int h=0; h<n_output; h++){\n    traceOutput[h] = (1 - traceParamOutput) * traceOutput[h] + traceParamOutput * output[h];\n    hiddenToOutputWeights(_, h) = hiddenToOutputWeights(_,h) + learningRateOutput * traceOutput[h] *(hidden - hiddenToOutputWeights(_,h));\n  }\n  \n  List retrn = List::create(Named(\"traceHidden\") = traceHidden,\n                            _[\"hidden\"] = hidden,\n                            _[\"inputToHiddenWeights\"] = inputToHiddenWeights,\n                            _[\"hiddenBiasWeights\"] = hiddenBiasWeights,\n                            _[\"traceOutput\"] = traceOutput,\n                            _[\"output\"] = output,\n                            _[\"hiddenToOutputWeights\"] = hiddenToOutputWeights,\n                            _[\"outputBiasWeights\"] = outputBiasWeights);\n    return(retrn);\n}\n\n//List batch(int n_epochs, ??){\n  \n//  Environment env = Environment::global_env();\n  \n//  NumericMatrix pre_input_hidden_weights()\n//  NumericMatrix pre_hidden_output_weights = \n//}\n\n// You can include R code blocks in C++ files processed with sourceCpp\n// (useful for testing and development). The R code will be automatically \n// run after the compilation.\n//\n\n/*** R\n\n*/",
    "created" : 1518105336250.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2951412013",
    "id" : "74B331FC",
    "lastKnownWriteTime" : 1518112512,
    "last_content_update" : 1518112512251,
    "path" : "~/GitHub/Int-Seg-Model/forwardPassCpp.cpp",
    "project_path" : "forwardPassCpp.cpp",
    "properties" : {
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "cpp"
}