{
    "collab_server" : "",
    "contents" : "#install.packages('dplyr')\nlibrary(dplyr)\n#install.packages(\"magrittr\")\nlibrary(magrittr)\n\n\ndisplay.learning.curves <- function(results){\n  for(i in 1:n.hidden){\n    layout(matrix(1:4, nrow=2))\n    #plot(results$history$learning.curve[,i], main=paste(\"Node\",i), ylim = 0,1000)\n    plot(results$history$bias.tracker[,i])\n    image(t(apply(matrix(results$network$input.hidden.weights[,i], nrow = 40),1,rev)))\n  }\n}\n\ndisplay.output.bias.tracker <- function(results){\n  for(i in 1:n.output){\n    plot(results$history$output.bias.tracker[,i], main=paste('Node', i))\n  }\n}\n\ntest.word.continuity <- function(network, words){\n  \n  n.letters <- 0\n  for(i in 1:length(words)){\n    n.letters <- n.letters + ncol(words[[i]])\n  }\n  \n  input.matrix <- matrix(0, ncol=n.input, nrow=n.letters)\n  r <- 1\n  for(i in 1:length(words)){\n    for(j in 1:ncol(words[[i]])){\n      input.matrix[r,] <- words[[i]][,j]\n      r <- r + 1\n    }\n  }\n  \n  temp.layer.activations(network, input.matrix)\n} \n\n\ntemp.layer.activations <- function(network, input.matrix){\n  \n  storing.activations <- matrix(0, nrow=nrow(input.matrix), ncol=n.output)\n  \n  for(i in 1:nrow(input.matrix)){\n    act.results <- forward.pass(input.matrix[i,], network$input.hidden.weights, network$hidden.bias.weights, network$hidden.output.weights, network$output.bias.weights)\n    storing.activations[i,] <- act.results$output\n  }\n  \n  output.results <- data.frame(letter=numeric(),output=numeric())\n  for(i in 1:nrow(storing.activations)){\n    for(j in which(storing.activations[i,] == max(storing.activations[i,]))){\n      output.results <- rbind(output.results, c(letter=i, output=j))  \n    }\n  }\n  colnames(output.results) <- c(\"letter\", \"output\")\n  \n  ## accuracy measurement ##\n  n <- 1\n  g <- (n.output*percent.act.output) * 3\n  g. <- (n.output*percent.act.output) * 3\n  \n  counter <- 0\n  for(h in 1:n.output){\n    counter <- counter + sum(c(output.results$output[n:g]) == h)\n  }\n  counter <- counter - length(unique(c(output.results$output[n:g])))\n  n <- g + 1\n  g <- g + g.\n  \n  for(h in 1:n.output){\n    counter <- counter + sum(c(output.results$output[n:g]) == h)\n  }\n  counter <- counter - length(unique(c(output.results$output[n:g])))\n  n <- g + 1\n  g <- g + g.\n  \n  for(h in 1:n.output){\n    counter <- counter + sum(c(output.results$output[n:g]) == h)\n  }\n  counter <- counter - length(unique(c(output.results$output[n:g])))\n  n <- g + 1\n  g <- g + g.\n  \n  for(h in 1:n.output){\n    counter <- counter + sum(c(output.results$output[n:g]) == h)\n  }\n  counter <- counter - length(unique(c(output.results$output[n:g])))\n  n <- g + 1\n  g <- g + g.\n  \n  for(h in 1:n.output){\n    counter <- counter + sum(c(output.results$output[n:g]) == h)\n  }\n  counter <- counter - length(unique(c(output.results$output[n:g])))\n  n <- g + 1\n  g <- g + g.\n  \n  for(h in 1:n.output){\n    counter <- counter + sum(c(output.results$output[n:g]) == h)\n  }\n  counter <- counter - length(unique(c(output.results$output[n:g])))\n  n <- g + 1\n  g <- g + g.\n  \n  for(h in 1:n.output){\n    counter <- counter + sum(c(output.results$output[n:g]) == h)\n  }\n  counter <- counter - length(unique(c(output.results$output[n:g])))\n  n <- g + 1\n  g <- g + g.\n  \n  for(h in 1:n.output){\n    counter <- counter + sum(c(output.results$output[n:g]) == h)\n  }\n  counter <- counter - length(unique(c(output.results$output[n:g])))\n  n <- g + 1\n  g <- g + g.\n  \n  for(h in 1:n.output){\n    counter <- counter + sum(c(output.results$output[n:(g-(n.output*(percent.act.output)))]) == h)\n  }\n  counter <- counter - length(unique(c(output.results$output[n:(g-(n.output*(percent.act.output)))])))\n  \n  percentage <- counter/(((n.output*(percent.act.output))*2*8.5))\n  ###\n\n  g <- ggplot(output.results, aes(x=letter, y=output)) + \n    geom_point()+\n    ylim(1,50)+\n    theme_bw()\n  print(g)\n  \n  print(storing.activations)\n  print(percentage)\n}\n\nvisualize.letter.activations <- function(network, input){\n  result <- forward.pass(input, network$input.hidden.weights, network$hidden.bias.weights, network$hidden.output.weights, network$output.bias.weights)\n  active.nodes <- which(result$hidden == max(result$hidden))\n  nplots <- length(active.nodes) + 2\n  nrow <- round(sqrt(nplots))\n  ncol <- ceiling(nplots / nrow)\n  layout(matrix(1:(nrow*ncol), nrow=nrow))\n  image(t(apply(matrix(input, nrow = 40),1,rev)))\n  for(act in active.nodes){\n    image(t(apply(matrix(network$input.hidden.weights[,act], nrow = 40),1,rev)))\n  }\n  all.active.nodes <- network$input.hidden.weights[,active.nodes]\n  average.weights <- calculate.mean.weights(all.active.nodes)\n  image(t(apply(matrix(average.weights, nrow = 40),1,rev)))\n}\n\ncalculate.mean.weights <- function(active.nodes){\n  m.fun <- function(x) { return(mean(x, na.rm=T)) }\n  average.weights <- apply(active.nodes, 1, m.fun)\n  return(average.weights)\n}\n\nhidden.layer.similarity <- function(letter, network, comparison.letter=NA){\n  result <- forward.pass(letter, network$input.hidden.weights, network$hidden.bias.weights, network$hidden.output.weights, network$output.bias.weights)\n  active.nodes <- which(result$hidden == max(result$hidden))\n  all.active.nodes <- network$input.hidden.weights[,active.nodes]\n  average.weights <- calculate.mean.weights(all.active.nodes)\n  if(!all(is.na(comparison.letter))){\n    similarity <- sum(abs(comparison.letter - average.weights), na.rm = T)\n  } else {\n    similarity <- sum(abs(letter - average.weights), na.rm = T)\n  }\n  return(similarity)\n}\n\nbatch.hidden.layer.learning <- function(letters, network){\n  result <- data.frame(input=names(letters), similarity=NA)\n  for(i in 1:nrow(result)){\n    result[i,\"similarity\"] <- hidden.layer.similarity(letters[[names(letters)[i]]], network)\n  }\n  return(result)\n}\n\nvisualize.hidden.layer.learning <- function(history){\n  plotting.data <- expand.grid(letter=names(letters), time=1:nrow(history$hidden.letter.similarity.tracking))\n  plotting.data$similarity <- mapply(function(l, t){\n    return(history$hidden.letter.similarity.tracking[t,which(names(letters)==l)])\n  }, plotting.data$letter, plotting.data$time)\n  summary.data <- plotting.data %>% group_by(time) %>% summarize(mean.similarity = mean(similarity))\n  ggplot(plotting.data, aes(x=time, y=similarity, color = letter))+ geom_line() + \n    geom_line(data=summary.data, aes(x=time, y=mean.similarity, color=NA), size=2)+\n    labs(x='time', y='difference between network representation and input letter')\n}\n\nhidden.layer.stability <- function(letter, input, network, history){\n  result <- forward.pass(input, network$input.hidden.weights, network$hidden.bias.weights, network$hidden.output.weights, network$output.bias.weights)\n  active.nodes <- which(result$hidden == max(result$hidden))\n  previous.active.nodes <- history$hidden.stability.tracking[[letter]]\n  change <- length(active.nodes) - sum(active.nodes %in% previous.active.nodes)\n  return(change)\n}\n\nbatch.hidden.layer.stability <- function(letters, network, history){\n  result <- data.frame(input=names(letters), stability=NA)\n  for(i in 1:nrow(result)){\n    result[i,\"stability\"] <- hidden.layer.stability(names(letters)[i], letters[[names(letters)[i]]], network, history)\n  }\n  return(result$stability)\n}\n\nupdate.hidden.layer.stability <- function(letters, network){\n  tracker <- sapply(names(letters), function(x){\n    result <- forward.pass(letters[[x]], network$input.hidden.weights, network$hidden.bias.weights, network$hidden.output.weights, network$output.bias.weights)\n    active.nodes <- which(result$hidden == max(result$hidden))\n    return(active.nodes)\n  }, USE.NAMES = T, simplify=FALSE)\n  return(tracker)\n}\n",
    "created" : 1513557652277.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3999479663",
    "id" : "A14BB2",
    "lastKnownWriteTime" : 1513655160,
    "last_content_update" : 1513655160219,
    "path" : "C:/Users/Tom/Desktop/GitHub/Int-Seg-Model/Visualize Output.R",
    "project_path" : "Visualize Output.R",
    "properties" : {
    },
    "relative_order" : 2,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}